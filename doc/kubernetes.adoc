= Kubernetes
:toc:
:toclevels: 2

toc::[]

== Overview

Kubernetes support is *experimental* and untested. üöß Use at your own risk! üöß 

== Prerequisites

* A running Kubernetes cluster (v1.25+)
* A storage class for persistent volumes (e.g., Longhorn, local-path, or cloud provider storage)
* link:https://gateway.envoyproxy.io[Envoy Gateway] installed for ingress routing (or adapt examples for legacy Ingress/nginx)
* External PostgreSQL database (or deploy one in-cluster)
* A domain name pointing to your cluster's ingress

== Architecture

The Kubernetes deployment consists of these components:

[cols="1,3"]
|===
|Component |Purpose

|Valkey
|In-memory store for Sidekiq job queue

|PersistentVolumeClaim
|Storage for uploaded images and generated content

|Deployment
|Main Terminus app + worker (sidekiq) as sidecar container

|Service
|Internal ClusterIP exposing the application

|HTTPRoute
|Envoy Gateway routing for external access

|BackendTrafficPolicy
|Connection buffer limits for large payloads (Envoy Gateway specific)
|===

== Valkey

Terminus uses link:https://valkey.io[Valkey] (redis-compatible in-memory storage). Deploy a dedicated Valkey instance or consider something like link:https://github.com/hyperspike/valkey-operator[Valkey Operator]

[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: terminus-valkey
spec:
  replicas: 1
  selector:
    matchLabels:
      app: terminus-valkey
  template:
    metadata:
      labels:
        app: terminus-valkey
    spec:
      containers:
      - name: valkey
        image: valkey/valkey:8-alpine
        ports:
        - containerPort: 6379
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
---
apiVersion: v1
kind: Service
metadata:
  name: terminus-valkey
spec:
  selector:
    app: terminus-valkey
  ports:
  - port: 6379
    targetPort: 6379
----

== Secrets

Create a Secret to store sensitive configuration. **Never commit secrets to git!**

[source,yaml]
----
apiVersion: v1
kind: Secret
metadata:
  name: terminus-secrets
type: Opaque
stringData:
  DATABASE_URL: postgres://user:password@postgres-host:5432/terminus
  APP_SECRET: your-secret-key-here
----

üí° Replace `DATABASE_URL` with your PostgreSQL connection string. Generate `APP_SECRET` using `openssl rand -hex 32`.

‚ö†Ô∏è In production, use a secure method to create this secret:

[source,bash]
----
kubectl create secret generic terminus-secrets \
  --from-literal=DATABASE_URL='postgres://user:password@host:5432/terminus' \
  --from-literal=APP_SECRET="$(openssl rand -hex 32)"
----

== Storage

Terminus needs a PersistentVolumeClaim for uploaded images and generated content:

[source,yaml]
----
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: terminus-uploads
spec:
  accessModes:
  - ReadWriteOnce
  storageClassName: longhorn
  resources:
    requests:
      storage: 2Gi
----

üí° Replace your cluster's storage class (`storageClassName`) with `local-path`, `gp2`, `standard`, etc.

== ConfigMap

Create a ConfigMap for non-sensitive application configuration:

[source,yaml]
----
apiVersion: v1
kind: ConfigMap
metadata:
  name: terminus-config
data:
  RACK_ATTACK_ALLOWED_SUBNETS: "10.42.0.0/16"
  TZ: "America/New_York"
----

üí° Set `RACK_ATTACK_ALLOWED_SUBNETS` to your cluster's pod CIDR or ingress controller subnet. To find your cluster's CIDR, try:

[source,bash]
----
# Get cluster pod CIDR
kubectl cluster-info dump | grep -m 1 cluster-cidr

# Or check node pod CIDRs
kubectl get nodes -o jsonpath='{.items[*].spec.podCIDR}'

# Or get ingress controller pod IPs
kubectl get pods -n envoy-gateway-system -o wide
----

‚ö†Ô∏è Setting this correctly is crucial for security. Only IPs in these subnets can bypass rate limiting. Since Envoy Gateway/nginx-ingress runs inside your cluster, you want to allow the cluster's internal network.

== Deployment

The main deployment runs two containers in the same pod:

* **terminus**: The main web application
* **worker**: Background job processor for image generation and scheduled tasks

Both containers share the same volume for uploads.

[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: terminus
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app.kubernetes.io/name: terminus
  template:
    metadata:
      labels:
        app.kubernetes.io/name: terminus
    spec:
      securityContext:
        fsGroup: 1000
      containers:
      - name: terminus
        image: ghcr.io/usetrmnl/terminus:latest
        ports:
        - containerPort: 2345
          name: http
        volumeMounts:
        - mountPath: /app/public/uploads
          name: data
        resources:
          requests:
            memory: "512Mi"
            cpu: "200m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        env:
        - name: TZ
          valueFrom:
            configMapKeyRef:
              name: terminus-config
              key: TZ
        - name: APP_SETUP
          value: "true"
        - name: API_URI
          value: https://terminus.example.com
        - name: HANAMI_PORT
          value: "2345"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: terminus-secrets
              key: DATABASE_URL
        - name: APP_SECRET
          valueFrom:
            secretKeyRef:
              name: terminus-secrets
              key: APP_SECRET
        - name: RACK_ATTACK_ALLOWED_SUBNETS
          valueFrom:
            configMapKeyRef:
              name: terminus-config
              key: RACK_ATTACK_ALLOWED_SUBNETS
        - name: KEYVALUE_URL
          value: redis://terminus-valkey:6379

      - name: sidekiq
        image: ghcr.io/usetrmnl/terminus:latest
        command: ["bundle", "exec", "sidekiq", "-r", "./config/sidekiq.rb"]
        volumeMounts:
        - mountPath: /app/public/uploads
          name: data
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        env:
        - name: TZ
          valueFrom:
            configMapKeyRef:
              name: terminus-config
              key: TZ
        - name: API_URI
          value: https://terminus.example.com
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: terminus-secrets
              key: DATABASE_URL
        - name: APP_SECRET
          valueFrom:
            secretKeyRef:
              name: terminus-secrets
              key: APP_SECRET
        - name: RACK_ATTACK_ALLOWED_SUBNETS
          valueFrom:
            configMapKeyRef:
              name: terminus-config
              key: RACK_ATTACK_ALLOWED_SUBNETS
        - name: KEYVALUE_URL
          value: redis://terminus-valkey:6379

      volumes:
      - name: data
        persistentVolumeClaim:
          claimName: terminus-uploads
----

üí° Use `Recreate` deployment strategy since the PVC is `ReadWriteOnce`. Replace `API_URI` with your actual domain.

üí° The container runs as UID 1000, so `fsGroup: 1000` is set to match file permissions.

== Service

Expose Terminus internally with a ClusterIP service:

[source,yaml]
----
apiVersion: v1
kind: Service
metadata:
  name: terminus
spec:
  ports:
  - port: 80
    targetPort: 2345
    name: http
  selector:
    app.kubernetes.io/name: terminus
----

== Ingress with Envoy Gateway

Route external traffic to Terminus using an HTTPRoute:

[source,yaml]
----
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
  name: terminus
spec:
  parentRefs:
  - name: eg
    namespace: envoy-gateway-system
  hostnames:
  - "terminus.example.com"
  rules:
  - matches:
    - path:
        type: PathPrefix
        value: /
    backendRefs:
    - name: terminus
      port: 80
----

üí° Replace `eg` with your Envoy Gateway instance name and update the hostname to your domain.

=== Alternative: Standard Ingress

If using nginx-ingress or another Ingress controller instead of Envoy Gateway:

[source,yaml]
----
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: terminus
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - terminus.example.com
    secretName: terminus-tls
  rules:
  - host: terminus.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: terminus
            port:
              number: 80
----

== Backend Traffic Policy (Envoy Gateway)

For Envoy Gateway deployments, increase the connection buffer limit to handle large image uploads:

[source,yaml]
----
apiVersion: gateway.envoyproxy.io/v1alpha1
kind: BackendTrafficPolicy
metadata:
  name: terminus-limits
spec:
  targetRef:
    group: gateway.networking.k8s.io
    kind: HTTPRoute
    name: terminus
  connection:
    bufferLimit: 10M
----

== Complete Manifest

Below is the complete manifest combining all components. Save as `terminus.yaml` and customize as needed:

[source,yaml]
----
# Secrets - create this first before deploying
apiVersion: v1
kind: Secret
metadata:
  name: terminus-secrets
type: Opaque
stringData:
  DATABASE_URL: postgres://user:password@host:5432/terminus
  APP_SECRET: changeme
---
# ConfigMap for non-sensitive configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: terminus-config
data:
  RACK_ATTACK_ALLOWED_SUBNETS: "10.42.0.0/16"
  TZ: "America/New_York"
---
# Valkey for Sidekiq job queue
apiVersion: apps/v1
kind: Deployment
metadata:
  name: terminus-valkey
spec:
  replicas: 1
  selector:
    matchLabels:
      app: terminus-valkey
  template:
    metadata:
      labels:
        app: terminus-valkey
    spec:
      containers:
      - name: valkey
        image: valkey/valkey:8-alpine
        ports:
        - containerPort: 6379
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
---
apiVersion: v1
kind: Service
metadata:
  name: terminus-valkey
spec:
  selector:
    app: terminus-valkey
  ports:
  - port: 6379
    targetPort: 6379
---
# Persistent storage for uploads
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: terminus-uploads
spec:
  accessModes:
  - ReadWriteOnce
  storageClassName: longhorn
  resources:
    requests:
      storage: 2Gi
---
# Main application + Sidekiq worker
apiVersion: apps/v1
kind: Deployment
metadata:
  name: terminus
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app.kubernetes.io/name: terminus
  template:
    metadata:
      labels:
        app.kubernetes.io/name: terminus
    spec:
      securityContext:
        fsGroup: 1000
      containers:
      - name: terminus
        image: ghcr.io/usetrmnl/terminus:latest
        ports:
        - containerPort: 2345
          name: http
        volumeMounts:
        - mountPath: /app/public/uploads
          name: data
        resources:
          requests:
            memory: "512Mi"
            cpu: "200m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        env:
        - name: TZ
          valueFrom:
            configMapKeyRef:
              name: terminus-config
              key: TZ
        - name: APP_SETUP
          value: "true"
        - name: API_URI
          value: https://terminus.example.com
        - name: HANAMI_PORT
          value: "2345"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: terminus-secrets
              key: DATABASE_URL
        - name: APP_SECRET
          valueFrom:
            secretKeyRef:
              name: terminus-secrets
              key: APP_SECRET
        - name: RACK_ATTACK_ALLOWED_SUBNETS
          valueFrom:
            configMapKeyRef:
              name: terminus-config
              key: RACK_ATTACK_ALLOWED_SUBNETS
        - name: KEYVALUE_URL
          value: redis://terminus-valkey:6379
      - name: sidekiq
        image: ghcr.io/usetrmnl/terminus:latest
        command: ["bundle", "exec", "sidekiq", "-r", "./config/sidekiq.rb"]
        volumeMounts:
        - mountPath: /app/public/uploads
          name: data
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        env:
        - name: TZ
          valueFrom:
            configMapKeyRef:
              name: terminus-config
              key: TZ
        - name: API_URI
          value: https://terminus.example.com
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: terminus-secrets
              key: DATABASE_URL
        - name: APP_SECRET
          valueFrom:
            secretKeyRef:
              name: terminus-secrets
              key: APP_SECRET
        - name: RACK_ATTACK_ALLOWED_SUBNETS
          valueFrom:
            configMapKeyRef:
              name: terminus-config
              key: RACK_ATTACK_ALLOWED_SUBNETS
        - name: KEYVALUE_URL
          value: redis://terminus-valkey:6379
      volumes:
      - name: data
        persistentVolumeClaim:
          claimName: terminus-uploads
---
apiVersion: v1
kind: Service
metadata:
  name: terminus
spec:
  ports:
  - port: 80
    targetPort: 2345
    name: http
  selector:
    app.kubernetes.io/name: terminus
---
# Envoy Gateway HTTPRoute (or use Ingress alternative above)
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
  name: terminus
spec:
  parentRefs:
  - name: eg
    namespace: envoy-gateway-system
  hostnames:
  - "terminus.example.com"
  rules:
  - matches:
    - path:
        type: PathPrefix
        value: /
    backendRefs:
    - name: terminus
      port: 80
---
# Envoy Gateway connection limits (optional, remove if using standard Ingress)
apiVersion: gateway.envoyproxy.io/v1alpha1
kind: BackendTrafficPolicy
metadata:
  name: terminus-limits
spec:
  targetRef:
    group: gateway.networking.k8s.io
    kind: HTTPRoute
    name: terminus
  connection:
    bufferLimit: 10M
----

‚ö†Ô∏è Before deploying, customize these values:

* **Secret**: Replace `DATABASE_URL` with your PostgreSQL connection string and generate `APP_SECRET` with `openssl rand -hex 32`
* **ConfigMap**: Set `RACK_ATTACK_ALLOWED_SUBNETS` to your cluster's pod CIDR (use commands in ConfigMap section to find it). Update `TZ` to your timezone if needed.
* **Storage**: Update `storageClassName` to match your cluster (e.g., `local-path`, `gp2`, `standard`)
* **API_URI**: Set to your actual domain in both `terminus` and `sidekiq` containers
* **Gateway**: Replace `eg` with your Envoy Gateway instance name and update the hostname

== Troubleshooting

=== Pods stuck in CrashLoopBackOff

Check logs for both containers:

[source,bash]
----
kubectl logs deployment/terminus --container terminus
kubectl logs deployment/terminus --container sidekiq
----

Common causes:

* Database connection failed - verify `DATABASE_URL` and that PostgreSQL is accessible
* Valkey connection failed - check if `terminus-valkey` service is running
* Missing `APP_SECRET` - ensure a valid secret is set

=== Images not generating

Sidekiq handles image generation. Check:

[source,bash]
----
kubectl logs deployment/terminus --container sidekiq
----

Ensure the shared volume is mounted correctly and both containers can write to `/app/public/uploads`.

=== Connection timeouts on large uploads

If using Envoy Gateway, apply the `BackendTrafficPolicy` to increase buffer limits. For nginx-ingress, add:

[source,yaml]
----
annotations:
  nginx.ingress.kubernetes.io/proxy-body-size: "50m"
----

=== Permission denied on uploads

Verify `fsGroup: 1000` is set in the pod's `securityContext`. The Terminus container runs as UID 1000.
